"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const gluegun_1 = require("gluegun");
const open_1 = __importDefault(require("open"));
const core_1 = require("@oclif/core");
// eslint-disable-next-line no-restricted-imports
const fetch_1 = require("@whatwg-node/fetch");
const compiler_1 = require("../command-helpers/compiler");
const DataSourcesExtractor = __importStar(require("../command-helpers/data-sources"));
const ipfs_1 = require("../command-helpers/ipfs");
const protocols_1 = __importDefault(require("../protocols"));
class PublishCommand extends core_1.Command {
    /**
     * Prompt the user to open up the browser to continue publishing the subgraph
     */
    async publishWithBrowser({ ipfsHash, webapp, subgraphId, protocolNetwork, }) {
        const answer = await core_1.ux.prompt(`Press ${chalk_1.default.green('y')} (or any key) to open up the browser to continue publishing or ${chalk_1.default.yellow('q')} to exit`);
        if (answer.toLowerCase() === 'q') {
            this.exit(0);
        }
        const url = new fetch_1.URL(webapp);
        const searchParams = new fetch_1.URLSearchParams(url.search);
        searchParams.set('id', ipfsHash);
        if (subgraphId) {
            searchParams.set('subgraphId', subgraphId);
        }
        if (protocolNetwork) {
            searchParams.set('network', protocolNetwork);
        }
        url.search = searchParams.toString();
        const openUrl = url.toString();
        gluegun_1.print.success(`Finalize the publish of the subgraph from the Graph CLI publish page. Opening up the browser to continue publishing at ${openUrl}`);
        await (0, open_1.default)(openUrl);
        return;
    }
    async run() {
        const { args: { 'subgraph-manifest': manifest }, flags: { 'ipfs-hash': ipfsHash, 'webapp-url': webUiUrl, ipfs, 'subgraph-id': subgraphId, 'protocol-network': protocolNetwork, }, } = await this.parse(PublishCommand);
        if (ipfsHash) {
            await this.publishWithBrowser({ ipfsHash, webapp: webUiUrl, subgraphId, protocolNetwork });
            return;
        }
        let protocol;
        try {
            const dataSourcesAndTemplates = await DataSourcesExtractor.fromFilePath(manifest);
            protocol = protocols_1.default.fromDataSources(dataSourcesAndTemplates);
        }
        catch (e) {
            this.error(e, { exit: 1 });
        }
        const compiler = (0, compiler_1.createCompiler)(manifest, {
            ipfs,
            outputDir: 'build/',
            outputFormat: 'wasm',
            skipMigrations: false,
            protocol,
        });
        // Exit with an error code if the compiler couldn't be created
        if (!compiler) {
            this.exit(1);
            return;
        }
        const result = await compiler.compile({ validate: true });
        if (result === undefined || result === false) {
            // Compilation failed, not deploying.
            process.exitCode = 1;
            return;
        }
        await this.publishWithBrowser({
            ipfsHash: result,
            webapp: webUiUrl,
            subgraphId,
            protocolNetwork,
        });
        return;
    }
}
PublishCommand.description = 'Publish to the Graph Network';
PublishCommand.args = {
    'subgraph-manifest': core_1.Args.string({
        default: 'subgraph.yaml',
    }),
};
PublishCommand.flags = {
    help: core_1.Flags.help({
        char: 'h',
    }),
    'subgraph-id': core_1.Flags.string({
        summary: 'Subgraph ID to publish to.',
        required: false,
    }),
    'protocol-network': core_1.Flags.string({
        summary: 'The network to use for the subgraph deployment.',
        options: ['arbitrum-one', 'arbitrum-sepolia'],
        default: 'arbitrum-one',
        required: false,
    }),
    ipfs: core_1.Flags.string({
        summary: 'Upload build results to an IPFS node.',
        char: 'i',
        default: ipfs_1.DEFAULT_IPFS_URL,
    }),
    'ipfs-hash': core_1.Flags.string({
        summary: 'IPFS hash of the subgraph manifest to deploy.',
        required: false,
    }),
    'webapp-url': core_1.Flags.string({
        summary: 'URL of the web UI you want to use to deploy.',
        required: false,
        default: 'https://cli.thegraph.com/publish',
    }),
};
exports.default = PublishCommand;
